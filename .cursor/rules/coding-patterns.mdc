---
description: 
globs: 
alwaysApply: false
---
Always prefer simple solutions

Avoid duplication of code whenever possible, which means checking for other areas of the codebase that might already have similar code and functionality

Write code that takes into account the different environments: dev, test, and prod

You are careful to only make changes that are requested or you are confident are well understood and related to the change being requested

When fixing an issue or bug, do not introduce a new pattern or technology without first exhausting all options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't have duplicate logic.

Keep the codebase very clean and organized

Avoid writing scripts in files if possible, especially if the script is likely only to be run once

Avoid having files over 200–300 lines of code. Refactor at that point.

Mocking data is only needed for tests, never mock data for dev or prod

Never add stubbing or fake data patterns to code that affects the dev or prod environments

Never overwrite my .env file without first asking and confirming

## 🎭 Playwright Testing Patterns

### **Test Structure Guidelines**
- Write descriptive test names that explain the user scenario
- Group related tests using `test.describe()` blocks
- Use `data-testid` attributes for reliable element selection
- Implement proper error handling and assertions in every test

### **Element Selection Best Practices**
```javascript
// ✅ CORRECT: Use data-testid for reliable selection
await page.locator('[data-testid="submit-button"]').click();

// ✅ CORRECT: Use semantic selectors
await page.locator('button[type="submit"]').click();

// ❌ WRONG: Avoid fragile selectors
await page.locator('.btn-primary').click(); // Too generic
```

### **Error Handling in Tests**
```javascript
// ✅ CORRECT: Handle potential errors gracefully
test('should handle form submission', async ({ page }) => {
  try {
    await page.goto('/form');
    await page.fill('[name="email"]', 'test@example.com');
    await page.click('[data-testid="submit"]');
    await expect(page.locator('.success')).toBeVisible();
  } catch (error) {
    console.log('Test failed:', error.message);
    // Take screenshot for debugging
    await page.screenshot({ path: 'test-failure.png' });
    throw error;
  }
});
```

### **Test Data Management**
- Use realistic test data that matches production scenarios
- Avoid hardcoded values in tests
- Create reusable test utilities for common operations
- Clean up test data after each test

### **Performance Testing**
```javascript
// ✅ CORRECT: Monitor performance metrics
test('should load page within acceptable time', async ({ page }) => {
  const startTime = Date.now();
  await page.goto('/dashboard');
  const loadTime = Date.now() - startTime;
  
  expect(loadTime).toBeLessThan(3000); // 3 seconds max
});
```

### **Cross-Browser Testing**
- Always test across multiple browsers (Chrome, Firefox, Safari)
- Handle browser-specific differences gracefully
- Use responsive design testing for mobile devices
- Test both desktop and mobile viewports